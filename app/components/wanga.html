<div class="row">
    <div class="content col-md-10 offset-md-1">
        <article>
            <h4>Алгоритми сімейства WANGA</h4>
            <p>
                Алгоритми сімейства ВАНГА [5] призначені для заповнення прогалин в таблицях з різнотипними змінними [6].
                Почнемо з опису алгоритмів для таблиці, всі n ознак в якій виміряні в одній і тій же шкалі відносин.
            </p>

            <ul class="nav nav-tabs" id="myTab" role="tablist">
                <li class="nav-item active">
                    <a class="nav-link" target="_self" data-toggle="tab" href="#wanga-r" role="tab"
                       aria-controls="wanga-r">Wanga-R</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" target="_self" data-toggle="tab" href="#wanga-i" role="tab"
                       aria-controls="wanga-i">Wanga-I</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" target="_self" data-toggle="tab" href="#wanga-n" role="tab"
                       aria-controls="wanga-n">Wanga-N</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" target="_self" data-toggle="tab" href="#wanga-0" role="tab"
                       aria-controls="wanga-0">Wanga-0</a>
                </li>
            </ul>

            <div class="tab-content">
                <div class="tab-pane" id="wanga-r" role="tabpanel">
                    <h5>WANGA – R</h5>
                    <p>
                        Нехай А - таблиця з пропущеним елементом аij. Всі інші елементи таблиці відомі. Для вибору
                        компетентної
                        підтаблиці розміром в s рядків і q стовпців скористаємося такою процедурою. Виберемо елемент
                        alk. На
                        перетинах i-го і l-го рядків з j-м і k-м стовпчиками знаходяться чотири елементи таблиці: alk,
                        alj, aik
                        і
                        невідомий елемент aij. Якщо ознаки пов'язані сильною прямою залежністю, то відношення двох
                        елементів
                        k-го
                        стовпця буде таким же або майже таким, як і відношення двох елементів j-го стовпця. Тоді з
                        передбачуваною
                        рівністю відносин alk: aik = alj: aij можна отримати варіант a' оцінки ( "підказки") елемента:
                        a'lk =
                        alj *
                        aik: alk. Повторивши цю процедуру для всіх інших елементів таблиці, ми отримаємо (n-1) * (m-1)
                        варіантів
                        підказок: a'11, a'12, ..., a'lk, ..., a '(n- 1) (m-1).
                    </p>
                    <p>
                        Виділимо з них підказки, отримані за участю елементів l-го рядка, і знайдемо їх дисперсію Dl.
                        Величину
                        Ll =
                        1: (Dl + 1) приймемо в якості запобіжної компетентності l-го рядка. Ll досягає максимального
                        значення 1,
                        якщо дисперсія Dl дорівнює нулю, і зі зростанням дисперсії, залишаючись позитивною величиною.
                        Аналогічно
                        по
                        дисперсії Dk підказок за участю всіх елементів k-го стовпця знайдемо його компетентність Lk = 1:
                        (Dk +
                        1).
                        Сформуємо компетентну підтаблицю A', включивши в неї s найкомпетентніших рядків і q
                        найкомпетентніших
                        стовпців.
                    </p>
                    <p>
                        Процес заповнення прогалини алгоритмом ВАНГА-Р полягає в наступному. Приєднуємо до таблиці A'
                        елементи
                        j-го
                        стовпця і i-го рядка. Перебираємо всі четвірки елементів, які знаходяться на перетині двох
                        стовпців -
                        j-го і
                        k-го і двох рядків - i-тий і l-тий. Невідомий елемент a(ij), що входить до складу всіх цих
                        четвірок,
                        обчислюємо за описаним вище способом і отримуємо s * q варіанти підказок: a'11, a'21, ..., a's1,
                        a'12,
                        a'22
                        , ..., a'lk, ..., a'sq. Остаточне рішення про значення пропущеного елемента отримуємо у вигляді
                        середньозваженої суми підказок:
                        a '' ij = {∑a 'lk * L lk} / ∑L lk для l = 1 - s і k = 1 - q.
                    </p>
                    <p>
                        Тут ваговий коефіцієнт підказки від елемента lk дорівнює його компетентності, яка визначається
                        так: L lk
                        =
                        Li * Lk. Ступінь довіри P до отриманого рішення можна оцінити через величину дисперсії D всіх s
                        * q
                        підказок: P = 1: (D + 1).
                    </p>
                </div>
                <div class="tab-pane" id="wanga-i" role="tabpanel">
                    <h5>WANGA – I</h5>
                    <p>Якщо дані в таблиці А заміряні в шкалі інтервалів, то мінімальним "підказуючим" елементом в
                        алгоритмі
                        ВАНГА-І буде підматрица, що складається з шести елементів, що стоять на перетинах двох стовпців
                        (j і k)
                        і
                        трьох рядків (i-, l-, і t-й). Інваріантом шкали інтервалів є відношення різниць двох будь-яких
                        пар
                        елементів
                        одного і того ж стовпчика. Грунтуючись на цьому і на гіпотезі про прямий зв'язок між j-тим і
                        k-тим
                        стовпцями, можна записати:
                        {A ij -a lj}: {a lj -a tj} = {a ik -a lk}: {a lk -a tk}.
                        Звідси отримуємо варіант підказки пропущеного елемента:
                        a'klt = a lj + {[a lj -a tj] * [a ik -a lk]: [a lk -a tk]}.
                    </p>
                    <p>
                        Повторивши ці операції за участю всіх парних поєднань з (m-1) рядків і всіх (n-1) стовпців,
                        отримаємо G
                        підказок. Виділимо підказки, отримані за участю елементів l-го рядка (їх буде (m-2) * (n-1)
                        штук),
                        визначимо
                        їх дисперсію Dl і по ній - компетентність l-того рядка Ll = 1 / (Dl + 1).
                        Грунтуючись на таких оцінках, виберемо s найбільш компетентних рядків.
                    </p>
                    <p>
                        Аналогічним способом знайдемо і q найбільш компетентних стовпців, сформувавши в результаті
                        компетентну
                        підматрицю s на q. Компетентність кожного елемента цієї подматріци L lk = Ll * Lk. Описаним вище
                        методом
                        знайдемо підказки від елементів цієї підматриці і отримаємо остаточний варіант заповнення
                        пропущеного
                        елемента, усереднивши підказки з їх вагами L lk. Про довіру до цього результату можна судити за
                        величиною P
                        = 1: (D + 1), де D - дисперсія всіх підказок від компетентної підматриці.
                    </p>
                </div>
                <div class="tab-pane" id="wanga-n" role="tabpanel">
                    <h5>WANGA – N</h5>
                    <p>Розглянемо таблицю A, ознаки в якій виміряні в шкалі найменувань. Ім'я пропущеного елемента а ij
                        може
                        бути
                        одним з d імен (1, 2, ..., j, ..., d), що містяться в j-тому стовпці, або новим (d + 1) -м ім'ям
                        x.
                        Переглянемо всі підказуючі четвірки елементів, що стоять на перетині рядків i і l і стовпців j і
                        k.
                        Підказку
                        будемо шукати, виходячи з наступного припущення: якщо i-й і l-й елементи k-го стовпця названі
                        одним і
                        тим же
                        ім'ям, то і в j-му стовпці елементи i-го і l-го рядків повинні мати однакові імена, тобто:
                        a'ij = a lj, якщо a ik = a lk
                        і навпаки,
                        a'ij ≠ a lj, якщо a ik ≠ a lk
                    </p>
                    <p>
                        Знайдемо підказки від всіх (m-1) * (n-1) таких четвірок і виберемо підказки, отримані за участю
                        елементів
                        k-го стовпця. Підрахуємо серед них число підказок, які голосували за кожне з d імен (w +) і
                        проти
                        кожного з
                        них (w-). Віднімемо голоси "проти" з голосів "за": w = (w +) - (w-). Додавши до отриманих
                        результатів
                        величину wmin, отримаємо d невід'ємних чисел w '. Помножимо їх на нормуючий коефіцієнт g, такий,
                        що ∑w '
                        * g
                        = 1 при f = 1 - d. Тепер можна знайти ентропію отриманих значень Hk і через неї компетентність
                        k-го
                        стовпця:
                        Lk = 1: (Hk + 1).
                    </p>
                    <p>
                        Зібравши підказки, отримані за участю всіх елементів l-го рядка, ми аналогічним способом
                        знайдемо її
                        компетентність Ll. Таким шляхом обирається компетентна підтаблиця з s рядків і q, що мають
                        найбільші
                        компетентності. Компетентність кожного елемента lk цієї підтаблиці дорівнює L lk = Ll * Lk.
                    <p>
                        Від кожного елемента підтаблиці виходить своя підказка, яка враховується в лічильнику голосів
                        "за" і
                        "проти"
                        з вагою відповідної компетентності. Якщо величини wf для всіх імен виявляться негативними, то
                        робиться
                        висновок про те, що пропущене ім'я не входить до складу d наявних імен. Серед імен, що мають
                        позитивну
                        величину wf, вибирається ім'я з wf max і це ім'я вставляється в порожню клітинку таблиці. Мірою
                        довіри
                        до
                        прийнятого рішення може служити величина, знайдена через ентропію розподілу голосів, як це
                        описано вище.
                        Якщо у вихідній таблиці більш, ніж один пропуск, то прогнозувати можна кожен пропущений елемент
                        незалежно
                        від інших ("паралельна" стратегія) або по черзі з використанням усіх елементів, як вихідних, так
                        і
                        передбачених на попередніх кроках ( "послідовна" стратегія). При послідовної стратегії потрібно
                        починати
                        з
                        передбачення того елемента, для якого ступінь довіри максимальний.
                    </p>
                </div>
                <div class="tab-pane" id="wanga-0" role="tabpanel">
                    <h5>WANGA – O</h5>
                    <p>
                        Якщо всі ознаки в таблиці A виміряні в шкалі порядку, то прогалини в ній заповнюються алгоритмом
                        ВАНГА -
                        0.
                        Перетворимо всі стовпці, привівши їх значення до шкали нормованих рангів [4]. Інваріантним до
                        перетворень
                        шкали порядку є судження такого роду: якщо a lk > a ik, то і a lj > a ij. Звідси виходить один з
                        трьох
                        можливих варіантів "підказки":
                        a'ij > a lj, якщо a ik > a lk,
                        a'ij = a lj, якщо a ik = a lk і
                        a'ij < a lj, якщо a ik < a lk.
                    </p>
                    <p>
                        Використання всіх елементів стовпців j і k дасть (m-1) варіантів підказок, які можуть не
                        збігатися або
                        навіть суперечити один одному. Оцінювати загальний результат будемо за таким правилом. Поставимо
                        у
                        відповідність m рангових номерами m накопичувачів 1, 2, ..., v, ..., m. Якщо підказка каже, що
                        невідомий
                        елемент дорівнює v, то додамо одиницю в v-й накопичувач. Якщо підказка каже, що шуканий ранг
                        більше v,
                        то в
                        кожен накопичувач з номером, більшим v, додамо величину, рівну 1: (m-v). Якщо ж підказка a'ij <
                        v, то у
                        відрізку від 1-ї до (v-1) -й додамо величину рівну 1: (v-1). У підсумку в кожному відрізку
                        накопичиться
                        величина, яка відображає "число голосів" за приналежність значення до того чи іншого рангу.
                        Після
                        нормування
                        суми всіх "голосів" до одиниці невизначеність підказок можна оцінити по ентропії
                        H = -∫_(v=1)^m〖p_v*log⁡〖p_v 〗 〗,
                        де p_v - частка голосів за ранг v.
                    </p>
                    <p>
                        Компетентність k-го стовпця приймемо рівної Lk = 1: (H + 1). При "одностайному" голосуванні за
                        один і
                        той же
                        ранг позитивна величина Lk досягає максимального значення, рівного 1.
                        Якщо в процесі роботи з усіма стовпчиками накопичувати підказки, що виходили за участю елементів
                        l-го
                        рядка,
                        то описаним вище шляхом можна отримати оцінку її компетентності Ll. Користуючись цими оцінками
                        можна
                        вибрати
                        компетентну підтаблицю A', яка містить s рядків і q стовпців. Компетентність кожного елемента a
                        lk цієї
                        підтаблиці приймемо рівної L lk = Li * Lk.
                    </p>
                    <p>
                        Повторимо визначення підказок за участю всіх s * q елементів з A '. Тепер для отримання
                        загального
                        результату в накопичувачі будемо додавати відповідні долі не від одиниці, а від величини Llk.
                        Розподіл
                        набраних рангами голосів дозволяє знайти остаточне рішення: пропущеного значенням присвоюється
                        ранг,
                        який
                        набрав найбільшу кількість голосів. Ентропія отриманого розподілу голосів Н дозволить нам
                        оцінити ступінь
                        довіри P до цього результату: P = 1: (H + 1).
                    </p>
                </div>
            </div>
        </article>
    </div>

    <script>
        var position = 1;
        var tabsWrapper = $('#myTab');
        var tabContent = $('.tab-content');

        var tabChange = function () {
            var tab = tabsWrapper.find('> li:nth-child(' + position + ')');
            var link = tab.find('a');
            tabContent.css({ opacity: 0 });
            link.css({ opacity: 0 });
            link.tab('show');
            if (position < tabsWrapper.find('> li').length) {
                position++;
            } else {
                position = 1;
            }
            link.animate({ opacity: 1 }, 500);
            tabContent.animate({ opacity: 1 }, 500);
        };

        tabChange();
        var tabCycle = setInterval(tabChange, 5000);

        $(function () {
            $('.nav-tabs a').click(function (e) {
                var link = $(this);
                link.css({ opacity: 0 });
                tabContent.css({ opacity: 0 });
                e.preventDefault();
                clearInterval(tabCycle);
                link.tab('show');
                link.animate({ opacity: 1 }, 500);
                tabContent.animate({ opacity: 1 }, 500);
            });
        });

    </script>
</div>